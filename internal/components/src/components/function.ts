import fs from "fs";
import path from "path";
import crypto from "crypto";
import { globSync } from "glob";
import archiver from "archiver";
import type { Loader, BuildOptions } from "esbuild";
import {
  Input,
  Output,
  ComponentResource,
  ComponentResourceOptions,
  asset,
  output,
  all,
  interpolate,
} from "@pulumi/pulumi";
import * as aws from "@pulumi/aws";
import { FunctionCodeUpdater } from "./function-code-updater.js";
import { AWS } from "./helpers/aws.js";
import { Duration } from "./util/duration.js";

const RETENTION = {
  "1 day": 1,
  "3 days": 3,
  "5 days": 5,
  "1 week": 7,
  "2 weeks": 14,
  "1 month": 30,
  "2 months": 60,
  "3 months": 90,
  "4 months": 120,
  "5 months": 150,
  "6 months": 180,
  "1 year": 365,
  "13 months": 400,
  "18 months": 545,
  "2 years": 731,
  "3 years": 1096,
  "5 years": 1827,
  "6 years": 2192,
  "7 years": 2557,
  "8 years": 2922,
  "9 years": 3288,
  "10 years": 3653,
  infinite: 0,
};

export interface FunctionNodeJSArgs {
  /**
   * Configure additional esbuild loaders for other file extensions
   *
   * @example
   * ```js
   * nodejs: {
   *   loader: {
   *    ".png": "file"
   *   }
   * }
   * ```
   */
  loader?: Input<Record<string, Loader>>;

  /**
   * Packages that will be excluded from the bundle and installed into node_modules instead. Useful for dependencies that cannot be bundled, like those with binary dependencies.
   *
   * @example
   * ```js
   * nodejs: {
   *   install: ["pg"]
   * }
   * ```
   */
  install?: Input<string[]>;

  /**
   * Use this to insert an arbitrary string at the beginning of generated JavaScript and CSS files.
   *
   * @example
   * ```js
   * nodejs: {
   *   banner: "console.log('Function starting')"
   * }
   * ```
   */
  banner?: Input<string>;

  /**
   * This allows you to customize esbuild config.
   */
  esbuild?: Input<BuildOptions>;

  /**
   * Enable or disable minification
   *
   * @default true
   *
   * @example
   * ```js
   * nodejs: {
   *   minify: false
   * }
   * ```
   */
  minify?: Input<boolean>;
  /**
   * Configure format
   *
   * @default "esm"
   *
   * @example
   * ```js
   * nodejs: {
   *   format: "cjs"
   * }
   * ```
   */
  format?: Input<"cjs" | "esm">;
  /**
   * Configure if sourcemaps are generated when the function is bundled for production. Since they increase payload size and potentially cold starts they are not generated by default. They are always generated during local development mode.
   *
   * @default false
   *
   * @example
   * ```js
   * nodejs: {
   *   sourcemap: true
   * }
   * ```
   */
  sourcemap?: Input<boolean>;

  /**
   * If enabled, modules that are dynamically imported will be bundled as their own files with common dependencies placed in shared chunks. This can help drastically reduce cold starts as your function grows in size.
   *
   * @default false
   *
   * @example
   * ```js
   * nodejs: {
   *   splitting: true
   * }
   * ```
   */
  splitting?: Input<boolean>;
}

export interface FunctionUrlArgs {
  /**
   * The authorization for the function URL
   * @default "none"
   * @example
   * ```js
   * {
   *   url: {
   *     authorization: "iam",
   *   },
   * }
   * ```
   */
  authorization?: Input<"none" | "iam">;
  /**
   * CORS support for the function URL
   * @default true
   * @example
   * ```js
   * {
   *   url: {
   *     cors: true,
   *   },
   * }
   * ```
   *
   * ```js
   * {
   *   url: {
   *     cors: {
   *       allowedMethods: ["GET", "POST"],
   *       allowedOrigins: ['https://example.com'],
   *     },
   *   },
   * }
   * ```
   */
  cors?: Input<boolean | aws.types.input.lambda.FunctionUrlCors>;
}

export interface FunctionLoggingArgs {
  /**
   * The duration function logs are kept in CloudWatch Logs.
   *
   * When updating this property, unsetting it doesn't retain the logs indefinitely. Explicitly set the value to "infinite".
   * @default Logs retained indefinitely
   * @example
   * ```js
   * {
   *   logging: {
   *     retention: "1 week"
   *   }
   * }
   * ```
   */
  retention?: Input<keyof typeof RETENTION>;
}

export interface FunctionArgs
  extends Omit<
    aws.lambda.FunctionArgs,
    "handler" | "code" | "s3Bucket" | "s3Key" | "role" | "environment"
  > {
  bundle: Input<string>;
  bundleHash?: Input<string>;
  handler: Input<string>;
  environment?: Input<Record<string, Input<string>>>;
  policies?: Input<aws.types.input.iam.RoleInlinePolicy[]>;
  streaming?: Input<boolean>;
  injections?: Input<string[]>;
  region?: Input<aws.Region>;
  logging?: Input<FunctionLoggingArgs>;
  /**
   * Enable function URLs, a dedicated endpoint for your Lambda function.
   * @default Disabled
   * @example
   * ```js
   * {
   *   url: true
   * }
   * ```
   *
   * ```js
   * {
   *   url: {
   *     authorization: "iam",
   *     cors: {
   *       allowedOrigins: ['https://example.com'],
   *     }
   *   }
   * }
   * ```
   */
  url?: Input<boolean | FunctionUrlArgs>;
  /**
   * Used to configure nodejs function properties
   */
  nodejs?: Input<FunctionNodeJSArgs>;
}

export class Function extends ComponentResource {
  private function: aws.lambda.Function;
  private role: aws.iam.Role;
  private fnUrl: Output<aws.lambda.FunctionUrl | undefined>;
  private missingSourcemap?: boolean;

  constructor(
    name: string,
    args: FunctionArgs,
    opts?: ComponentResourceOptions
  ) {
    super("sst:sst:Function", name, args, opts);

    const injections = normalizeInjections();
    const environment = normalizeEnvironment();
    const streaming = normalizeStreaming();
    const region = normalizeRegion();
    const logging = normalizeLogging();
    const url = normalizeUrl();

    const provider = new aws.Provider(`${name}-provider`, { region });

    const newHandler = wrapHandler();
    const role = createRole();
    const zipPath = zipBundleFolder();
    const bundleHash = args.bundleHash ?? calculateHash();
    const file = createBucketObject();
    const fn = createFunction();
    updateFunctionCode();
    createLogGroup();
    const fnUrl = createUrl();

    this.function = fn;
    this.role = role;
    this.fnUrl = fnUrl;

    function normalizeInjections() {
      return output(args.injections).apply((injections) => injections ?? []);
    }

    function normalizeEnvironment() {
      return output(args.environment).apply((environment) => environment ?? {});
    }

    function normalizeStreaming() {
      return output(args.streaming).apply((streaming) => streaming ?? false);
    }

    function normalizeRegion() {
      return output(args.region).apply((region) => region ?? app.aws.region);
    }

    function normalizeLogging() {
      return output(args.logging).apply((logging) => ({
        ...logging,
        retention: logging?.retention ?? "infinite",
      }));
    }

    function normalizeUrl() {
      return output(args.url).apply((url) => {
        if (url === false || url === undefined) return;

        const defaultAuthorization = "none" as const;
        const defaultCors: aws.types.input.lambda.FunctionUrlCors = {
          allowHeaders: ["*"],
          allowMethods: ["*"],
          allowOrigins: ["*"],
        };

        if (url === true) {
          return { authorization: defaultAuthorization, cors: defaultCors };
        }

        return {
          authorization: url.authorization ?? defaultAuthorization,
          cors:
            url.cors === false
              ? {}
              : url.cors === true
              ? defaultCors
              : {
                  ...defaultCors,
                  ...url.cors,
                },
        };
      });
    }

    function calculateHash() {
      return zipPath.apply(async (zipPath) => {
        const hash = crypto.createHash("sha256");
        hash.update(await fs.promises.readFile(zipPath));
        return hash.digest("hex");
      });
    }

    function wrapHandler() {
      return all([args.handler, args.bundle, injections]).apply(
        async ([handler, bundle, injections]) => {
          if (injections.length === 0) return handler;

          const {
            dir: handlerDir,
            name: oldHandlerName,
            ext: oldHandlerExt,
          } = path.posix.parse(handler);
          const oldHandlerFunction = oldHandlerExt.replace(/^\./, "");
          const newHandlerName = "server-index";
          const newHandlerFunction = "handler";
          await fs.promises.writeFile(
            path.join(bundle, handlerDir, `${newHandlerName}.mjs`),
            streaming
              ? [
                  `export const ${newHandlerFunction} = awslambda.streamifyResponse(async (event, context) => {`,
                  ...injections,
                  `  const { ${oldHandlerFunction}: rawHandler} = await import("./${oldHandlerName}.mjs");`,
                  `  return rawHandler(event, context);`,
                  `});`,
                ].join("\n")
              : [
                  `export const ${newHandlerFunction} = async (event, context) => {`,
                  ...injections,
                  `  const { ${oldHandlerFunction}: rawHandler} = await import("./${oldHandlerName}.mjs");`,
                  `  return rawHandler(event, context);`,
                  `};`,
                ].join("\n")
          );
          return path.posix.join(
            handlerDir,
            `${newHandlerName}.${newHandlerFunction}`
          );
        }
      );
    }

    function createRole() {
      return new aws.iam.Role(`${name}-role`, {
        assumeRolePolicy: aws.iam.assumeRolePolicyForPrincipal({
          Service: "lambda.amazonaws.com",
        }),
        inlinePolicies: args.policies,
        managedPolicyArns: [
          "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole",
        ],
      });
    }

    function zipBundleFolder() {
      // Note: cannot point the bundle to the `.open-next/server-function`
      //       b/c the folder contains node_modules. And pnpm node_modules
      //       contains symlinks. Pulumi cannot zip symlinks correctly.
      //       We will zip the folder ourselves.
      return output(args.bundle).apply(async (bundle) => {
        const zipPath = path.resolve(app.paths.temp, name, "code.zip");
        await fs.promises.mkdir(path.dirname(zipPath), {
          recursive: true,
        });

        await new Promise(async (resolve, reject) => {
          const ws = fs.createWriteStream(zipPath);
          const archive = archiver("zip");
          archive.on("warning", reject);
          archive.on("error", reject);
          // archive has been finalized and the output file descriptor has closed, resolve promise
          // this has to be done before calling `finalize` since the events may fire immediately after.
          // see https://www.npmjs.com/package/archiver
          ws.once("close", () => {
            resolve(zipPath);
          });
          archive.pipe(ws);

          archive.glob("**", { cwd: bundle, dot: true });
          await archive.finalize();
        });

        return zipPath;
      });
    }

    function createBucketObject() {
      return new aws.s3.BucketObjectv2(
        `${name}-code`,
        {
          key: interpolate`${name}-code-${bundleHash}.zip`,
          bucket: region.apply((region) => AWS.bootstrap.forRegion(region)),
          source: zipPath.apply((zipPath) => new asset.FileArchive(zipPath)),
        },
        {
          provider,
        }
      );
    }

    function createFunction() {
      return new aws.lambda.Function(
        `${name}-function`,
        {
          code: new asset.AssetArchive({
            index: new asset.StringAsset("exports.handler = () => {}"),
          }),
          role: role.arn,
          ...args,
          handler: newHandler,
          environment: {
            variables: environment,
          },
        },
        { provider }
      );
    }

    function createLogGroup() {
      new aws.cloudwatch.LogGroup(`${name}-log-group`, {
        name: interpolate`/aws/lambda/${fn.name}`,
        retentionInDays: logging.apply(
          (logging) => RETENTION[logging.retention]
        ),
      });
    }

    function createUrl() {
      return url.apply((url) => {
        if (url === undefined) return;

        return new aws.lambda.FunctionUrl(`${name}-url`, {
          functionName: fn.name,
          authorizationType: url.authorization.toUpperCase(),
          invokeMode: streaming.apply((streaming) =>
            streaming ? "RESPONSE_STREAM" : "BUFFERED"
          ),
          cors: url.cors,
        });
      });
    }

    function updateFunctionCode() {
      new FunctionCodeUpdater(`${name}-code-updater`, {
        functionName: fn.name,
        s3Bucket: file.bucket,
        s3Key: file.key,
        region,
      });
    }
  }

  public get aws() {
    return {
      function: this.function,
      role: this.role,
    };
  }

  public get url() {
    return this.fnUrl.apply((url) => url?.functionUrl ?? output(undefined));
  }

  /** @internal */
  public getConstructMetadata() {
    return {
      type: "Function" as const,
      data: {
        arn: this.function.arn,
        runtime: this.function.runtime,
        handler: this.function.handler,
        missingSourcemap: this.missingSourcemap === true ? true : undefined,
        localId: this.urn,
        secrets: [] as string[],
      },
    };
  }
}
