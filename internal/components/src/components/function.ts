import fs from "fs/promises";
import path from "path";
import crypto from "crypto";
import { globSync } from "glob";
import type { Loader, BuildOptions } from "esbuild";
import pulumi from "@pulumi/pulumi";
import { FunctionCodeUpdater } from "./function-code-updater";

export interface FunctionNodeJSArgs {
  /**
   * Configure additional esbuild loaders for other file extensions
   *
   * @example
   * ```js
   * nodejs: {
   *   loader: {
   *    ".png": "file"
   *   }
   * }
   * ```
   */
  loader?: Record<string, Loader>;

  /**
   * Packages that will be excluded from the bundle and installed into node_modules instead. Useful for dependencies that cannot be bundled, like those with binary dependencies.
   *
   * @example
   * ```js
   * nodejs: {
   *   install: ["pg"]
   * }
   * ```
   */
  install?: string[];

  /**
   * Use this to insert an arbitrary string at the beginning of generated JavaScript and CSS files.
   *
   * @example
   * ```js
   * nodejs: {
   *   banner: "console.log('Function starting')"
   * }
   * ```
   */
  banner?: string;

  /**
   * This allows you to customize esbuild config.
   */
  esbuild?: BuildOptions;

  /**
   * Enable or disable minification
   *
   * @default true
   *
   * @example
   * ```js
   * nodejs: {
   *   minify: false
   * }
   * ```
   */
  minify?: pulumi.Input<boolean>;
  /**
   * Configure format
   *
   * @default "esm"
   *
   * @example
   * ```js
   * nodejs: {
   *   format: "cjs"
   * }
   * ```
   */
  format?: "cjs" | "esm";
  /**
   * Configure if sourcemaps are generated when the function is bundled for production. Since they increase payload size and potentially cold starts they are not generated by default. They are always generated during local development mode.
   *
   * @default false
   *
   * @example
   * ```js
   * nodejs: {
   *   sourcemap: true
   * }
   * ```
   */
  sourcemap?: boolean;

  /**
   * If enabled, modules that are dynamically imported will be bundled as their own files with common dependencies placed in shared chunks. This can help drastically reduce cold starts as your function grows in size.
   *
   * @default false
   *
   * @example
   * ```js
   * nodejs: {
   *   splitting: true
   * }
   * ```
   */
  splitting?: boolean;
}

export interface FunctionArgs
  extends Omit<
    aws.lambda.FunctionArgs,
    "handler" | "code" | "s3Bucket" | "s3Key" | "role" | "environment"
  > {
  bundle: pulumi.Input<string>;
  bundleHash?: pulumi.Input<string>;
  handler: pulumi.Input<string>;
  environment?: Record<string, pulumi.Input<string>>;
  policies?: aws.types.input.iam.RoleInlinePolicy[];
  streaming?: boolean;
  injections?: string[];
  region?: aws.Region;
  /**
   * Used to configure nodejs function properties
   */
  nodejs?: pulumi.Input<FunctionNodeJSArgs>;
}

export class Function extends pulumi.ComponentResource {
  private function: aws.lambda.Function;
  private role: aws.iam.Role;
  private missingSourcemap?: boolean;

  constructor(
    name: string,
    args: FunctionArgs,
    opts?: pulumi.ComponentResourceOptions
  ) {
    super("sst:sst:Function", name, args, opts);

    const {
      handler,
      bundle,
      bundleHash: bundleHashRaw,
      environment,
      policies,
      streaming,
      injections,
      region,
    } = {
      environment: {},
      streaming: false,
      injections: [],
      ...args,
    };

    const provider = new aws.Provider("provider", {
      // TODO test these are not required
      //accessKey: app.aws.AWS_ACCESS_KEY_ID,
      //secretKey: app.aws.AWS_SECRET_ACCESS_KEY,
      //token: app.aws.AWS_SESSION_TOKEN,
      region: region || app.aws.region,
    });

    const bundleHash =
      bundleHashRaw ??
      pulumi.all([bundle]).apply(([bundle]) => calculateHash(bundle));
    const newHandler = wrapHandler();
    const role = createRole();
    const file = createBucketObject();
    const fn = createFunction();
    updateFunctionCode();

    this.function = fn;
    this.role = role;

    async function calculateHash(bundle: string) {
      const hash = crypto.createHash("sha256");
      const filePaths = globSync("**", {
        ignore: "**/node_modules/**",
        dot: true,
        nodir: true,
        follow: true,
        cwd: bundle,
      });

      for (const filePath of filePaths) {
        hash.update(await fs.readFile(path.resolve(bundle, filePath)));
      }

      return hash.digest("hex");
    }

    async function wrapHandler() {
      if (injections.length === 0) return handler;

      const {
        dir: handlerDir,
        name: oldHandlerName,
        ext: oldHandlerExt,
      } = path.posix.parse(handler);
      const oldHandlerFunction = oldHandlerExt.replace(/^\./, "");
      const newHandlerName = "server-index";
      const newHandlerFunction = "handler";
      await fs.writeFile(
        path.join(bundle, handlerDir, `${newHandlerName}.mjs`),
        streaming
          ? [
              `export const ${newHandlerFunction} = awslambda.streamifyResponse(async (event, context) => {`,
              ...injections,
              `  const { ${oldHandlerFunction}: rawHandler} = await import("./${oldHandlerName}.mjs");`,
              `  return rawHandler(event, context);`,
              `});`,
            ].join("\n")
          : [
              `export const ${newHandlerFunction} = async (event, context) => {`,
              ...injections,
              `  const { ${oldHandlerFunction}: rawHandler} = await import("./${oldHandlerName}.mjs");`,
              `  return rawHandler(event, context);`,
              `};`,
            ].join("\n")
      );
      return path.posix.join(
        handlerDir,
        `${newHandlerName}.${newHandlerFunction}`
      );
    }

    function createRole() {
      return new aws.iam.Role(`${name}-role`, {
        assumeRolePolicy: aws.iam.assumeRolePolicyForPrincipal({
          Service: "lambda.amazonaws.com",
        }),
        inlinePolicies: policies,
        managedPolicyArns: [
          "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole",
        ],
      });
    }

    function createBucketObject() {
      // TODO test it should fail without using pulumi.interpolate?
      return new aws.s3.BucketObjectv2(
        `${name}-code`,
        {
          key: pulumi.interpolate`${name}-code-${bundleHash}.zip`,
          // TODO - CLI fix: access bootstrap bucket in another region
          bucket: app.bootstrap.bucket,
          source: new pulumi.asset.FileArchive(bundle),
        },
        {
          provider,
        }
      );
    }

    function createFunction() {
      return new aws.lambda.Function(
        `${name}-function`,
        {
          code: new pulumi.asset.AssetArchive({
            index: new pulumi.asset.StringAsset("exports.handler = () => {}"),
          }),
          role: role.arn,
          ...args,
          handler: newHandler,
        },
        { provider }
      );
    }

    function updateFunctionCode() {
      new FunctionCodeUpdater(
        `${name}-code-updater`,
        {
          functionName: fn.name,
          s3Bucket: file.bucket,
          s3Key: file.key,
        },
        { provider }
      );
    }
  }

  public get aws() {
    return {
      function: this.function,
      role: this.role,
    };
  }

  /** @internal */
  public getConstructMetadata() {
    return {
      type: "Function" as const,
      data: {
        arn: this.function.arn,
        runtime: this.function.runtime,
        handler: this.function.handler,
        missingSourcemap: this.missingSourcemap === true ? true : undefined,
        localId: this.urn,
        secrets: [] as string[],
      },
    };
  }
}
