import fs from "fs/promises";
import {
  Input,
  ComponentResourceOptions,
  output,
  Output,
} from "@pulumi/pulumi";
import type { Loader, BuildOptions } from "esbuild";
import { build } from "../runtime/cloudflare.js";
import { Component } from "./component";
import { WorkersDevUrl } from "./providers/workers-dev-url";

export interface WorkerNodeJSArgs {
  /**
   * Configure additional esbuild loaders for other file extensions
   *
   * @example
   * ```js
   * nodejs: {
   *   loader: {
   *    ".png": "file"
   *   }
   * }
   * ```
   */
  loader?: Input<Record<string, Loader>>;
  /**
   * Use this to insert an arbitrary string at the beginning of generated JavaScript and CSS files.
   *
   * @example
   * ```js
   * nodejs: {
   *   banner: "console.log('Function starting')"
   * }
   * ```
   */
  banner?: Input<string>;
  /**
   * This allows you to customize esbuild config.
   */
  esbuild?: Input<BuildOptions>;
  /**
   * Enable or disable minification
   *
   * @default true
   *
   * @example
   * ```js
   * nodejs: {
   *   minify: false
   * }
   * ```
   */
  minify?: Input<boolean>;
  /**
   * Configure format
   *
   * @default "esm"
   *
   * @example
   * ```js
   * nodejs: {
   *   format: "cjs"
   * }
   * ```
   */
  format?: Input<"cjs" | "esm">;
  /**
   * Configure if sourcemaps are generated when the function is bundled for production. Since they increase payload size and potentially cold starts they are not generated by default. They are always generated during local development mode.
   *
   * @default false
   *
   * @example
   * ```js
   * nodejs: {
   *   sourcemap: true
   * }
   * ```
   */
  sourcemap?: Input<boolean>;
}

export interface WorkerArgs {
  /**
   * Path to the handler for the worker.
   * @example
   * ```js
   * {
   *   handler: "packages/functions/src/index.ts"
   * }
   * ```
   */
  handler: Input<string>;
  /**
   * Enable dev URLs, a dedicated endpoint for your Worker.
   * @default Disabled
   * @example
   * ```js
   * {
   *   devUrl: true
   * }
   * ```
   */
  devUrl?: Input<boolean>;
  /**
   * Used to configure nodejs function properties
   */
  nodejs?: Input<WorkerNodeJSArgs>;
}

export class Worker extends Component {
  private script: Output<cloudflare.WorkerScript>;
  private workersDevUrl: WorkersDevUrl;

  constructor(name: string, args: WorkerArgs, opts?: ComponentResourceOptions) {
    super("sst:sst:Worker", name, args, opts);

    const parent = this;

    const nDevUrl = normalizeDevUrl();

    const handler = buildHandler();
    const script = createScript();
    const workersDevUrl = createWorkersDevUrl();

    this.script = script;
    this.workersDevUrl = workersDevUrl;

    function normalizeDevUrl() {
      return output(args.devUrl).apply((v) => v ?? false);
    }

    function buildHandler() {
      const buildResult = output(args).apply(async (args) => {
        const result = await build(name, args);
        if (result.type === "error") {
          console.log(result);
          throw new Error(result.errors.join("\n"));
        }
        return result;
      });
      return buildResult.handler;
    }

    function createScript() {
      return output(handler).apply(
        async (handler) =>
          new cloudflare.WorkerScript(
            `${name}Script`,
            {
              name,
              accountId: $app.providers?.cloudflare?.accountId!,
              content: (await fs.readFile(handler)).toString(),
              module: true,
            },
            { parent }
          )
      );
    }

    function createWorkersDevUrl() {
      return new WorkersDevUrl(
        `${name}DevUrl`,
        {
          accountId: $app.providers?.cloudflare?.accountId!,
          scriptName: script.name,
          enabled: nDevUrl,
        },
        { parent }
      );
    }
  }

  public get devUrl() {
    return this.workersDevUrl.url.apply((url) =>
      url ? `https://${url}` : url
    );
  }

  public get nodes() {
    return {
      worker: this.script,
    };
  }
}
