import fs from "fs/promises";
import {
  Input,
  ComponentResourceOptions,
  output,
  Output,
  all,
  jsonStringify,
} from "@pulumi/pulumi";
import type { Loader, BuildOptions } from "esbuild";
import { build } from "../runtime/cloudflare.js";
import { Component } from "./component";
import { WorkersDevUrl } from "./providers/workers-dev-url";
import { buildLinkableData, isAWSLinkable, registerLinkType } from "./link.js";
import { iam } from "@pulumi/aws";

export interface WorkerNodeJSArgs {
  /**
   * Configure additional esbuild loaders for other file extensions
   *
   * @example
   * ```js
   * nodejs: {
   *   loader: {
   *    ".png": "file"
   *   }
   * }
   * ```
   */
  loader?: Input<Record<string, Loader>>;
  /**
   * Use this to insert an arbitrary string at the beginning of generated JavaScript and CSS files.
   *
   * @example
   * ```js
   * nodejs: {
   *   banner: "console.log('Function starting')"
   * }
   * ```
   */
  banner?: Input<string>;
  /**
   * This allows you to customize esbuild config.
   */
  esbuild?: Input<BuildOptions>;
  /**
   * Enable or disable minification
   *
   * @default true
   *
   * @example
   * ```js
   * nodejs: {
   *   minify: false
   * }
   * ```
   */
  minify?: Input<boolean>;
  /**
   * Configure format
   *
   * @default "esm"
   *
   * @example
   * ```js
   * nodejs: {
   *   format: "cjs"
   * }
   * ```
   */
  format?: Input<"cjs" | "esm">;
  /**
   * Configure if sourcemaps are generated when the function is bundled for production. Since they increase payload size and potentially cold starts they are not generated by default. They are always generated during local development mode.
   *
   * @default false
   *
   * @example
   * ```js
   * nodejs: {
   *   sourcemap: true
   * }
   * ```
   */
  sourcemap?: Input<boolean>;
}

export interface WorkerArgs {
  /**
   * Path to the handler for the worker.
   * @example
   * ```js
   * {
   *   handler: "packages/functions/src/index.ts"
   * }
   * ```
   */
  handler: Input<string>;
  /**
   * Enable dev URLs, a dedicated endpoint for your Worker.
   * @default Disabled
   * @example
   * ```js
   * {
   *   devUrl: true
   * }
   * ```
   */
  devUrl?: Input<boolean>;
  /**
   * Used to configure nodejs function properties
   */
  nodejs?: Input<WorkerNodeJSArgs>;
  /**
   * Link resources to the function.
   * This will grant the function permissions to access the linked resources at runtime.
   *
   * @example
   * ```js
   * {
   *   link: [myBucket, stripeKey],
   * }
   * ```
   */
  link?: Input<any[]>;
}

export class Worker extends Component {
  private script: Output<cloudflare.WorkerScript>;
  private workersDevUrl: WorkersDevUrl;

  constructor(name: string, args: WorkerArgs, opts?: ComponentResourceOptions) {
    super("sst:sst:Worker", name, args, opts);

    const parent = this;

    const devUrlEnabled = normalizeDevUrl();

    const linkData = buildLinkData();
    const iamCredentials = createAwsCredentials();
    const handler = buildHandler();
    const script = createScript();
    const workersDevUrl = createWorkersDevUrl();

    this.script = script;
    this.workersDevUrl = workersDevUrl;

    function normalizeDevUrl() {
      return output(args.devUrl).apply((v) => v ?? false);
    }

    function buildLinkData() {
      if (!args.link) return [];
      return output(args.link).apply((links) => {
        const linkData = buildLinkableData(links);
        for (const datum of linkData) {
          all([datum]).apply(([value]) => {
            registerLinkType({
              type: value.type,
              name: value.name,
            });
          });
        }
        return linkData;
      });
    }

    function createAwsCredentials() {
      return output(args.link ?? []).apply((links) => {
        const permissions = links.flatMap((l) => {
          if (!isAWSLinkable(l)) return [];
          return [l.getSSTAWSPermissions()];
        });

        if (permissions.length === 0) return;

        const user = new aws.iam.User(
          `${name}AwsUser`,
          { forceDestroy: true },
          { parent }
        );

        new aws.iam.UserPolicy(
          `${name}AwsPolicy`,
          {
            user: user.name,
            policy: jsonStringify({
              Statement: permissions.map((p) => ({
                Effect: "Allow",
                Action: p.actions,
                Resource: p.resources,
              })),
            }),
          },
          { parent }
        );

        const keys = new aws.iam.AccessKey(
          `${name}AwsCredentials`,
          { user: user.name },
          { parent }
        );

        return keys;
      });
    }

    function buildHandler() {
      const buildResult = all([args, linkData]).apply(
        async ([args, linkData]) => {
          const result = await build(name, { ...args, links: linkData });
          if (result.type === "error") {
            throw new Error(result.errors.join("\n"));
          }
          return result;
        }
      );
      return buildResult.handler;
    }

    function createScript() {
      return all([handler, iamCredentials]).apply(
        async ([handler, iamCredentials]) =>
          new cloudflare.WorkerScript(
            `${name}Script`,
            {
              name,
              accountId: $app.providers?.cloudflare?.accountId!,
              content: (await fs.readFile(handler)).toString(),
              module: true,
              plainTextBindings: iamCredentials
                ? [
                    {
                      name: "AWS_ACCESS_KEY_ID",
                      text: iamCredentials.id,
                    },
                  ]
                : [],
              secretTextBindings: iamCredentials
                ? [
                    {
                      name: "AWS_SECRET_ACCESS_KEY",
                      text: iamCredentials.secret,
                    },
                  ]
                : [],
            },
            { parent }
          )
      );
    }

    function createWorkersDevUrl() {
      return new WorkersDevUrl(
        `${name}DevUrl`,
        {
          accountId: $app.providers?.cloudflare?.accountId!,
          scriptName: script.name,
          enabled: devUrlEnabled,
        },
        { parent }
      );
    }
  }

  public get devUrl() {
    return this.workersDevUrl.url.apply((url) =>
      url ? `https://${url}` : url
    );
  }

  public get nodes() {
    return {
      worker: this.script,
    };
  }
}
